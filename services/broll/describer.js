import { v4 as uuidv4 } from "uuid";
import { BRoll } from "../../model/BRoll.js";

/**
 * Register a B-roll clip with its description
 * Each B-roll must have text meaning for semantic matching
 */
import ffmpeg from "fluent-ffmpeg";
import ffmpegInstaller from "@ffmpeg-installer/ffmpeg";
import fs from "fs";
import path from "path";
import Groq from "groq-sdk";
import dotenv from "dotenv";

dotenv.config();
ffmpeg.setFfmpegPath(ffmpegInstaller.path);

const groq = new Groq({ apiKey: process.env.GROQ_API_KEY });

const TEMP_DIR = "uploads/temp";
if (!fs.existsSync(TEMP_DIR)) {
  fs.mkdirSync(TEMP_DIR, { recursive: true });
}

/**
 * Extract a frame from video - tries multiple timestamps
 */
async function extractFrame(videoPath) {
  const timestamps = ['0.5', '1', '2']; // Try multiple positions for short videos
  
  for (const ts of timestamps) {
    try {
      const result = await new Promise((resolve, reject) => {
        const filename = `frame_${Date.now()}.jpg`;
        const outputPath = path.join(TEMP_DIR, filename);

        ffmpeg(videoPath)
          .screenshots({
            timestamps: [ts],
            filename: filename,
            folder: TEMP_DIR,
            size: '640x?'
          })
          .on('end', () => {
            // Verify file was created and has content
            if (fs.existsSync(outputPath) && fs.statSync(outputPath).size > 1000) {
              resolve(outputPath);
            } else {
              reject(new Error(`Frame at ${ts}s too small or missing`));
            }
          })
          .on('error', (err) => reject(err));
      });
      
      console.log(`  üì∏ Extracted frame at ${ts}s`);
      return result;
    } catch (err) {
      console.log(`  ‚ö†Ô∏è Frame at ${ts}s failed: ${err.message}`);
      continue;
    }
  }
  
  throw new Error("Could not extract any valid frame from video");
}
/**
 * Generate description using Llama 4 Scout Vision
 */
async function generateDescription(imagePath) {
  try {
    const imageBuffer = fs.readFileSync(imagePath);
    const base64Image = imageBuffer.toString('base64');
    const dataUrl = `data:image/jpeg;base64,${base64Image}`;

    console.log(`  ÔøΩ Sending to Vision API (${Math.round(imageBuffer.length/1024)}KB)...`);

    const response = await groq.chat.completions.create({
      messages: [
        {
          role: "user",
          content: [
            { type: "text", text: "Describe this image in one concise sentence focusing on the main visual subject and action. This description will be used for semantic video matching." },
            { type: "image_url", image_url: { url: dataUrl } }
          ]
        }
      ],
      model: "meta-llama/llama-4-scout-17b-16e-instruct",
      temperature: 0.1,
      max_tokens: 100
    });

    const description = response.choices[0].message.content;
    
    if (!description || description.length < 10) {
      console.warn(`  ‚ö†Ô∏è Vision returned short response: "${description}"`);
      return "Unidentified B-roll footage";
    }
    
    return description.trim();
  } catch (error) {
    console.error(`  ‚ùå Vision API error: ${error.message}`);
    return "Unidentified B-roll footage";
  } finally {
    // Cleanup temp image
    if (fs.existsSync(imagePath)) fs.unlinkSync(imagePath);
  }
}

/**
 * Register a B-roll clip with its description
 * Each B-roll must have text meaning for semantic matching
 */
export async function describeBroll({ filePath, fileName, description, duration = 2.5 }) {
  let finalDescription = description;

  // Auto-generate description if missing
  if (!finalDescription || finalDescription.trim().length < 3) {
    console.log(`  ü§ñ Auto-generating description for ${fileName}...`);
    try {
      const framePath = await extractFrame(filePath);
      finalDescription = await generateDescription(framePath);
      console.log(`  ‚ú® Generated: "${finalDescription}"`);
    } catch (error) {
      console.error("  ‚ùå Auto-description failed:", error.message);
      finalDescription = `B-roll clip: ${fileName}`;
    }
  }

  const broll_id = `broll_${uuidv4().slice(0, 8)}`;

  const broll = new BRoll({
    broll_id,
    file_path: filePath,
    file_name: fileName,
    description: finalDescription.trim(),
    duration_sec: duration,
    embedding: [],
    used: false
  });

  await broll.save();

  return {
    success: true,
    broll_id,
    description: broll.description,
    autoGenerated: !description
  };
}

/**
 * Get all B-rolls
 */
export async function getAllBrolls() {
  return await BRoll.find({});
}

/**
 * Get unused B-rolls (available for allocation)
 */
export async function getAvailableBrolls() {
  return await BRoll.find({ used: false });
}

/**
 * Mark B-roll as used
 */
export async function markBrollUsed(broll_id) {
  return await BRoll.findOneAndUpdate(
    { broll_id },
    { used: true },
    { new: true }
  );
}

/**
 * Reset all B-rolls to unused state
 */
export async function resetBrollUsage() {
  return await BRoll.updateMany({}, { used: false });
}

/**
 * Update B-roll embedding
 */
export async function updateBrollEmbedding(broll_id, embedding) {
  return await BRoll.findOneAndUpdate(
    { broll_id },
    { embedding },
    { new: true }
  );
}

/**
 * Regenerate description for an existing B-roll using Vision API
 */
export async function regenerateBrollDescription(broll_id, filePath) {
  console.log(`  üîÑ Regenerating description for ${broll_id}...`);
  
  try {
    const framePath = await extractFrame(filePath);
    const newDescription = await generateDescription(framePath);
    
    // Update in database
    await BRoll.findOneAndUpdate(
      { broll_id },
      { description: newDescription, embedding: [] }, // Clear embedding to force re-embedding
      { new: true }
    );
    
    console.log(`  ‚ú® New description: "${newDescription.substring(0, 80)}..."`);
    return newDescription;
  } catch (error) {
    console.error(`  ‚ùå Regeneration failed: ${error.message}`);
    throw error;
  }
}
